# 算法

master公式:

![image-20230201195610136](C:\Users\Sarry\AppData\Roaming\Typora\typora-user-images\image-20230201195610136.png)



使用不同的算法对一个条件进行验证的时候,一定要注意条件是否是一样的.



和做数学题目一样,一定要看清楚题目的条件.



得到一个数最右边的1,eor&(~eor+1);

去掉一个数最右边的1,eor&(eor-1);



分享个字母大小写转换的方法：

1. 统一转成大写：ch & 0b11011111 简写：ch & 0xDF
2. 统一转成小写：ch | 0b00100000 简写：ch | 0x20

比较的时候注意加上小括号哦，因为位运算优先级比较低。



快速排序中一定要注意每次排好一个数.因此返回的数组的取值要指定好.不要重复返回相同的值.



完全二叉树:最后一层即使不满,也要从左往右依次变满.

​	左孩子:2*i+1		2i+1=(i<<1)|1;
​	右孩子:2*i+2		
​	父:(i-1)/2
​	
堆:大根堆或者小根堆.一定是完全二叉树.

大根堆实例:提供方法isEmpty( ),pop( ),size( ),push( )

数组中的值进行拷贝的时候,使用数组内的值速度更快.
	
	

优先级队列底层就是堆,默认是小根堆.



# 2.6

### 1.得到链表的中间结点,中间结点的前一个结点.

利用快慢指针.

### 

### 2.判断链表是否是回文链表:

简单做法:利用栈将节点放入,然后倒出来,一一对比

复杂做法:利用得到中间结点,将链表的后半部分节点进行逆转,然后一一比较,最后再将链表还原.



### 3.对链表进行partition:

简单做法:利用数组,直接将链表的数字放入数组里面,然后利用数组进行partition

复杂做法:利用六个节点,把小于区,等于区,大于区的节点分别穿起来,最后再把他们一起穿起来



### 4.克隆一个有next和rand指针的链表:

简单做法:利用哈希表,先遍历一遍,直接将所有的节点创建到哈希表里面.在遍历一遍,将哈希表中的节点串起来.

复杂做法:直接在原链表的基础上设置对应,将新节点创建在原来老节点的下一个.最后将新链表分离出来.



### 5.找到链表的环的入口:

简单做法:使用一个set,每次将节点放入其中,当找到第一个已经存在的节点时,说明这个节点就是入口.

复杂做法:使用快慢指针,首次相遇时让快指针返回,每次只走一步,这样两次节点相遇时即为环的入口.



### 6.两个无环链表相交求交点:

简单做法:若两个链表无环,将其中一个链表放入set,遍历另一个链表,哪一个在set中有就是交点

复杂做法:让两个链表走完,如果走到最后都不相等,那么一定不相交.然后得出两个链表长度的差值,让较长的链表先走多余的步数,然后一起走,相交的第一个节点即为交点.



### 7.两个有环链表相交:

一个有环,一个无环:不可能

情况:

1.两个都有环,各自相交

2.不在环内相交:若两个链表的入环结点相同,当做无环来看待.

3.在环内相交.第一个链表在环内转一圈,如果遇到了另一个链表的入环结点则相交.



### 8.不给定链表的结点,只给定一个结点,删除这个结点:

简单做法:把下一个结点的值赋给这个结点,这个结点下一个指向下一个的下一个.

实际上:必须要有头结点才能够删除.



# 2.7

### 1.不使用递归实现二叉树先序中序后序:

先序:利用栈实现,弹出就打印,如果有右,压入右,如果有左,压入左.

后序:先使用头右左实现,再倒入一个栈中,这样就实现左右头.使用两个栈

中序:整条左边界依次入栈,弹出就打印,再来到右结点

后序不使用两个栈的方法:



### 2.二叉树的按层遍历:

使用一个队列,



### 3.二叉树的最大宽度:

简单做法:使用一个map,存入结点和其对应的等级.

复杂做法:不使用map,每次记录每一层的最后一个结点.



### 4.二叉树的递归序序列化

利用递归和队列,每次将头结点的值加进去,null也需要加入.

反序列化:利用递归建左树右树.



### 5.二叉树的层序列化

利用一个队列装入序列化结果,另一个装入结点.如果左树不为空,则既序列也加入队列,右树同理.

反序列化:准备一个备用的队列,首先将给定的队列的第一个放到其中作为头结点,然后向外倒出,如果不为空则将当前节点的左节点给他,下一个再不为空就将右节点给他,并且这两个节点加入下一层的队列里面,以此类推.



# 2.11

### 1.打印一颗二叉树

思路:利用递归,用右中左的顺序进行打印.



条件:每个结点知道自己的父亲父亲结点是谁.

### 2.某个节点的后续节点

简单方法:直接使用中序遍历,找到这个结点后面的节点.

复杂方法:

1.如果这个结点有右树,那么其下一个结点一定是右树上最左边的一个节点

2.如果没有右树,向上找到父节点,如果这个结点是上一个结点的左孩子,则就为这个结点.如果一直到上面都不是左树的话,则说明没有后继节点.



### 同理,某个结点的前驱结点.



### 3.随机构造出一颗二叉树.

随机建二叉树，随机概率如果小于0.3则为空节点，剩下就为一个结点，使用层级序列化.



# 2.13

### 1.一张纸条对折出现折痕

对折之后出现一个凹折痕,再次对折,在这个凹折痕的上面出现凹折痕,下面出现凸折痕,在凸折痕的上方出现凹折痕,下方出现凸折痕.

解决办法:看做二叉树的中序遍历![image-20230213191943170](C:\Users\Sarry\AppData\Roaming\Typora\typora-user-images\image-20230213191943170.png)



## 二叉树的递归问题,树形dp



### 2.给定一颗二叉树的头结点head,返回这颗二叉树是不是平衡二叉树

思路:二叉树头结点向其两个节点要信息,如果两个都是平衡二叉树,并且两个的高度之差小于等于1,那么这个节点也满足平衡二叉树的条件.



### 3.给定一颗二叉树的头结点,任何两个节点之间都存在距离,返回整颗二叉树的最大距离

思路:从头结点开始向两颗子树要信息.距离存在两种情况,一种是和头结点没有关系,另一种是和头结点有关系.

如果和头结点没有关系,那么说明最大值就是子节点的最大值.

如果和头结点有关系,那么说明最大值就是两颗子树的高度之和+1.

综上所述,最大值就是在数学上求左子树的最大值,右子树的最大值和二者高度之和再加一这三者的最大值.

头结点需要向子树获取的信息有:子树的高度,子树的距离最大值.



### 4.给定一颗二叉树的头结点head,返回这颗二叉树中最大的二叉搜索子树的头结点

思路:搜索二叉树指的就是中序遍历严格递增的二叉树.

给定头结点,要求其左子树是搜索二叉树,右子树是搜索二叉树,并且左子树的最大值<头结点的值<右子树的最小值.

头结点需要向子树要的信息:是否是搜索二叉树,,要左子树的最大值,右子树的最小值,以及总共的大小是多少.



### 5.派对的最大快乐值问题

一个人可以管理很多的员工,每个员工有给定的快乐值.如果给一个员工的上级发了请帖,那么这个上级的员工就都不会参加派对.求员工们的最大快乐值.

思路:准备一个信息类,这个类记录员工来或者不来的快乐值.当现在需要得到一个人的快乐值的时候,他来的时候的快乐值等于他自己的快乐值加上他的员工都不来的快乐值,当他不来的时候的快乐值等于它的员工来或者不来的快乐值中较大的那一个相加起来,这样就能够得到最终的最大的快乐值.



### 6.求最大子矩阵的大小

程序员代码面试指南p26

思路:要求一个最大子矩阵的大小,每一层每一层的统计,如果这一层上的数为1则把上一层的数字累加下来,如果这一层的数字为0则直接置为0;这样求最大值的问题就变成了求每一层的这个最大值的大小.

在求每一层的最大值的时候,利用单调栈结构,求最大值.



# 2.14

### 1.给定一个苹果的数目,一个袋子只能装6个或者8个,如果可以装完,求最少的袋子的数目,不能就返回-1

思路:将100以内的袋子数目打印出来找规律,直接返回即可.



### 2.牛和羊吃草,每次吃的是4的某次方,谁最先把草吃完谁获胜.

思路:先使用递归求出暴力解,再根据其找规律.



### 3.一个数可以表示为连续的正整数相加则返回true,否则返回false,一个不行

思路:先利用暴力方法打印出来,再来找规律.

num是不是2的多少次方,num&(num-1)==0?



### 打表找规律

某个面试题,输入参数类型简单,并且只有一个实际参数

要求返回值的类型也简单并且只有一个

用暴力方法,把输入参数对应的返回值,打印出来看看有没有规律.



### 矩阵处理技巧:

### 4.zigzag打印矩阵

使用两个坐标来进行调度.不要纠结于打印的点的坐标.



### 5.转圈打印矩阵

用边缘的四个节点进行调度



### 6.旋转正方形矩阵

思路:同样使用边缘的四个节点,每次只旋转外圈的数字,然后旋转内圈的数据.



# 2.15

### 1.递归序列

f(n)=f(n-1)+f(n-2)

f(n)=f(n-1)+f(n-3)

采用时间复杂度为O(N),递归改迭代,以及时间复杂度为O(logN)分别实现.



### 2.开会问题

简单方法:暴力递归

复杂方法:按照开会的结束时间排序.



### 3.放灯问题,把空余的位置照亮需要多少灯.

简单方法:暴力,每个点都去尝试两种可能.

最优解:每次考虑当前位置应该放置哪一个值,如果当前为X,直接跳到下一个,如果当前为点则考虑后续情况,如果后续为X直接在这里放一个灯.如果后面两个都为点,则在中间放灯.



### 4.金条划分问题,把一个金条划分为指定的长度,每次切割耗费的代价为当前金条的长度,求最小代价

简单做法:直接枚举,每次将两个进行合并,得到最小值返回.

复杂做法:利用一个小根堆,每次将最小的两个合并,这样非叶子节点加起来就是最小的总代价.哈夫曼树.



### 5.项目问题,每个项目有其对应的花费和利润,怎么选择项目做,选择做项目的顺序

复杂做法:准备一个小根堆和一个大根堆,小根堆里存放花费,大根堆中存放利润高的项目.每次从利润高的项目中做项目,再去小根堆中解锁项目.

### 贪心需要多多练习.



### 并查集:

有若干个样本,类型都是一样的.默认一开始认为都是在单独的集合里.提供两个方法:

查询样本x和样本y是否属于同一个集合.

把x和y样本的集合里的所有元素合并为一个集合.

要求这两个条件的时间复杂度是O(1).

利用三张哈希表,第一张记录值和其对应的节点,第二张记录每个节点和其对应的父节点,第三张第三张记录每个头结点和其对应的节点的数目.



### 6.学生实例,身份证id,b站id,github id至少有一个相同则认为是同一个人.

并查集



# 2.16

### 1.两个user,a,b,c三个字段中只要有一个就认为是一个人.

并查集,提供两个功能,查询是否是同一个集合,以及合并两个集合.时间复杂度都是O(1).



## 2.实现图的接口



### 3.图的宽度优先遍历和深度优先遍历

宽度优先遍历用队列实现,深度优先遍历用栈实现



### 4.图的拓扑排序算法

有向无环图

不同事情之间有依赖关系,按照这种关系将完成事情的顺序列出来.

方法:在图中找到入度为0的点,删掉它以及其连接的边,继续删除.

准备一张节点和入度的哈希表,将入度为0的点放入一个队列.



### 5.最小生成树Kruskal算法

按照边的权值将所有的边排序,每次弹出最小的边看看有没有将点连起来,如果是则直接加入.使用并查集判断是否连通.

并查集擅长判断两个集合是否是同一集合.



### 6.Prim算法

从一个节点出发开始解锁,解锁与其相邻的边,从已经解锁的边里面选择一个最小的,看其有没有解锁新的节点.解锁了新的节点后,再看有没有解锁新的边.





# 2.17

### 1.迪杰特斯拉算法

给定一个点,求这个点到其他节点的最短距离.

解法:从头结点出发,找到距离自己所有的点,再找到距离最近的点,并且没有选择过的点,继续通过这个点的边进行寻找.

优化:需要更改小根堆里面的值的时候,需要自己手动实现堆.



### 2.使用小根堆优化dijkstra算法

上面的dijkstra算法每一次在找距离最小的节点的时候,需要遍历哈希表中所有的值,如果使用一个小根堆,那么每次就可以直接使用即可.但是这个小根堆里面的值可能发生修改,因此需要手动实现小根堆.

小根堆需要满足的条件:每次弹出一个最小值,并且这个弹出的值不能够再次弹出,可以使用set来记录弹出过的值.



### 3.汉诺塔问题

递归和非递归的时间复杂度一致



### 4.空间复杂度为O(1)逆序一个栈.

首先构造方法得到栈底的数.

然后得到这个数,再得到,再得到,然后压栈.



# 2.19

子串:必须要是连续的,从左向右

子序列:相对次序不能乱,但是不要求连续.

### 1.求出一个字符串的所有子序列.

思路:使用递归完成,每个位置上考虑有还是没有,直接向下执行.



### 2.求出一个字符串的所有子序列,不能出现相同的字面值.

思路:通过一个哈希表来记录加入过的字符串.



### 3.扩展:求出一个字符串的所有子序列,不能出现相同的字面值的个数.

简单思路:用上面的方法,直接统计递归.



### 4. 打印一个字符串的全部排列.

思路:每次考虑将当前的位置的和后面的位置进行交换,交换完之后要进行还原.



### 5.打印一个字符串的全部排列,要求不重复.

简单方法:使用hashset

复杂方法:在每一个位置上考虑开头的时候,使用一个序列来表示有没有有没有用这个开头的,如果没有就进行.

分支限界:提前将不可能发生的情况排除.



### 从左向右的尝试模型:

### 6.将字符串按照条件转化为指定的字符,1对应A,2对应B,以此类推.

递归思路:使用索引i,如果i到达最后则返回1,如果当前值为0,直接返回0.如果当前值为1,说明这个位置的结果有两种,一个是单独成一个值,还有一种是和右边的一个成一个值.如果为2,也有两种情况.如果为其他的,说明不能单独成值,直接看后面的结果.



### 7.给定两个长度为N的数组重量和价值,给定一个背包,返回你能够装下的最多的价值.

递归思路:对当前位置的货物进行尝试,要或者不要,返回要或者不要的最大值.如果当前的空间已经小于0了,说明这种方法不成立,是无效方案,直接返回-1.剩下有两种选择,一种是选择当前的货物.



### 范围上尝试的模型:

### 8.给定一个整型数组arr,代表数值不同的纸牌排成一条线.玩家A和玩家B依次拿走每张纸牌,A先拿,B后拿.但是每个玩家每次只能拿走最左或者最右的纸牌,返回最后获胜者的分数.

递归方法:构造两个函数,一个是在l到r上先手能够获得的最大值,一个是在l到r上后手能够获得的最小值 

先手函数:首先考虑最基本的情况,如果左右边界相等,则直接返回这一个值.否则返回左边的值加上在剩下的区间中后手和右边的值加上剩下的区间中后手的最大值.

后手函数:首先考虑最基本的情况,如果左右边界相等,则直接返回0. 否则返回两者中的最小值.



# 2.20

### 1.寄信问题.规定每个人必须要寄出一封信,并且不能寄给自己.求有多少种方法.

思路:首先得出base case,即n为0,1,2的情况,然后当人数为n的时候,假设A把信寄给了B,B寄给了A,这相当于就变成了f(n-2)的问题,如果B不寄给A,相当于A和B就变成了同一个人,就变成了f(n-1)的问题.这样的情况总共有n-1种,因此

f(n)=(n-1)*[f(n-1)+f(n-2)]



### 2.n皇后

简单思路:考虑当前位置有多少种放置的方法,如果索引到达了最后一个位置,显然只有一种.否则返回res加上后面的种类.

复杂思路:利用位运算,进行优化.用一个列限制符,左斜线限制符和右斜线限制符进行限制.



### 记忆化搜索下的动态规划:

### 3.一个机器人,在N个格子上走动,每次必须走动K步,问最终能来到P位置的方法有多少种.

简单思路:直接应用递归来进行求解.

复杂思路:使用dp数组添加缓存,这样以后就可以从缓存中获取数据,这样就可以省去递归中重复的计算过程.

### 记忆化搜索和经典动态规划基本等效.



### 4.给定指定的面额,求凑够指定金额的所有方法.

递归思路:从第一个位置开始,从0张到最大张数,每次去尝试.

改记忆化搜索:在return之前将这个值记录到数组里面.

### 动态规划可能细粒度过高,容易导致复杂.



# 2.21

### 1.贴纸问题

给定一个字符串,需用用给定的贴纸去凑够,求最少的贴纸张数.

### 设计递归的原则:递归使用的变量越少越好.

1.每一个可变参数的类型,不要比int更复杂

2.如果类型是一维线性结构,只需要做到记忆化搜索就好.

3.可变参数能少则少.



### 常见的4种尝试模型:

1.从左往右的尝试模型

2.范围上的尝试模型

3.多样本位置全对应的尝试模型

4.寻找业务限制的尝试模型.



### 动态规划的进一步优化:

1.空间压缩

2.状态化简

3.四边形不等式



### 2.两个字符串的最长公共子序列问题.

递归思路:i,j位置的最长字符串和i-1,j-1,i,j-1,以及i-1,j有关.



### 3.给定一个数组,代表每个人喝完咖啡准备刷杯子的时间.只有一台咖啡机一次只能洗一个杯子耗费时间a,也可以自己挥发干净耗费时间b.咖啡杯可以并行挥发,求最早完成时间.

思路:每次传入递归函数一个洗咖啡机能够空余的时间,然后比较当前杯子洗或者不洗的最小值即可.



### 数据结构与算法基础班完结.OVO



### 进阶班:

# 2.22

### 1.滑动窗口的最大值.

思路:使用一个双端队列,里面存放索引,保持一个从大到小的顺序.如果队列不为空并且当前值比队列尾部的值要大或者相等的时候,直接将队列尾弹出,然后把这个值加入.队列头部的索引就是当前窗口的最大值的位置.当窗口的左边界的值等于当前队列头部的索引的时候,说明头部索引失效,将其从前面弹出.



### 2.给定一个整型数组arr和一个整数num,某个arr中的子数组sub如果想达标必须要满足sub中最大值-sub中最小值<=num,返回arr中达标子数组的数量.

子数组:必须要连续.

思路:如果arr[l,r]达标,里面的任意一个子数组都达标.因为其子数组的最大值－最小值肯定会更小.

维持一个最大值的双端队列,维持一个最小值的双端队列,每次判断当前位置是否加入最大值或者加入最小值,如果到了某一个位置发现最大值减去最小值不满足要求,进行结算,以窗口的左端点为头,右端口的前一个为尾的全部子数列都满足要求.

然后让左窗口向右移动,更新最大值最小值队列,然后继续判断是否符合要求.



### 3.单调栈,找到一个数组中左边的比他小的索引和右边的比他小的索引.

如果没有相同的值:

思路:让栈从底到顶依次增大,如果当前要加入的值比栈顶的元素要小的话.将这个位置的值弹出,并且将其左边和右边的值记下来.



如果有相同的值:

让相同的值如果捧在一起就组成一个list.



### 4.给定一个只包含正整数的数组arr,求所有子数组中(sub累加和)*(sub中的最小值)是什么.

思路:划分值为数组中的当前值为当前的这个值,用单调栈找到以当前的数作为最小的值的最大的和,然后用和乘上当前的数,即可.



耐心,你的代码可能写的慢,但是实际上写的还是不错的.



### 5.递归改动态规划:

如果递归的参数比较多,可以将其抽取为一个方法,这样可以简化代码.使代码可以更加简洁明朗.



### 6.斐波那契数列:时间复杂度O(logN)

使用矩阵乘法,再用快速幂优化.



# 2.23

### 1.实现矩阵乘法快速幂

思路:将幂次变为二进制数,然后从右向左相乘,例如10的9次方变为10的8次方乘10. 

推广:F(n)=F(n-1)+F(n-3),则可以变成三阶矩阵再进行计算.

母牛生小牛问题,每只母牛每年可以生一只小牛,每只小牛三年后可以生小牛,母牛过了10年会死. 那么就变为F(n)=F(n-1)+F(n-3)-F(n-10).



### 2.给定一个数N,只有0和1两种字符组成的所有长度为N的字符串,如果某个字符串任何0字符的左边都有1紧挨着就认为合格.

找递推公式,是斐波那契数列.



### 3.扔球问题,给定很多球,但是袋子只能装10个,让每个球都等概率进入袋子.

思路:每个球出来时生成一个随机数,如果这个随机数小于10则进袋子.同时袋子内随机弹出一个.



# 2.24

### 1.KMP算法

思路:根据next数组得到每个字符的最大的前缀后缀的相等的个数.然后利用这个数组进行跳动,如果跳动到0的时候直接开始下一个字符的比对.

next数组的设计的思想也是如此.



### 2.判断两个字符串是否互为旋转词.

将这个字符串用两个拼在一起然后使用kmp.



### 3.两个二叉树判断一个是不是另一个的子树.

简单方法;使用递归判断.每个子树进行判断.

复杂方法:使用先序遍历将两个二叉树遍历.然后将字符串kmp变为字符数组kmp.



### 4.在一个无序数组中,求第k小的数.时间复杂度为O(N).

简单思路:利用荷兰国旗问题,如果划分值左边的数个数少,则在右边继续进行划分.

复杂思路:bfprt算法.总体思路仍然还是利用荷兰国旗的划分,但是划分值的选取可以进行优化到严格的O(n).每5个数字为一组,如果最后有多的则单独成为一组.每一组进行一个排序,找到组中的中间的数.然后继续返回这个由中间数构成的数组的中间的数字返回.

特点:主函数调用副函数,副函数返回主函数.组内排序可以使用插入排序来进行.



### 5.找到数组中前k小的数.

使用bfprt算法,首先找到第k小的,然后遍历数组,看看谁比这个数小,就加入数组.如果最终数组没有填满,则用这个找到的数填满.



### 6.最长回文子串

简单方法:从每一个位置向外扩,如果左边右边相等就继续扩张.但是这样只能够得到长度为奇数的回文串.

解决办法:在相邻两个字符之间添加一个新的符号,然后这样就可以包含所有的了,最终结果需要进行除以2.

复杂方法:manacher算法;以最大的回文区域划分一个最大的回形区域,这个区域内的关于中心点的回文区域数目对称.

如果确定了一个较大的区域,这个区域如果i在R内,直接等于i',如果i'区域在外,那么i回文区域直接等于R-i.如果i压线.

i在R外,暴力方法

i在R内,1.i'在内部.2.i'在外部.3.i'压线.



### 7.将一个字符串变为回文子串的最小代价.

思路:从左向右找到哪一个位置的回文子串可以包含到最后一个位置.然后找到其左边界,将其逆序即为最后的答案.



# 2.26

### 1.将奇数放到奇数位上,将偶数放到偶数位上.

思路:将两个指针分别指向0和1位置,表示一个存放奇数,一个存放偶数.每次从最后一个数来看,如果是奇数就与奇数位交换,如果是偶数就和偶数位交换.



### 2.Morris遍历

morris序:

当前节点cur,一开始cur来到整树头

1.cur无左树,cur=cur.right

2.cur有左树,找到左树最右节点,mostRight

​	1.mostright的右指针指向null,则mostright.right=cur,cur=cur.left.

​	2.mostright的右指针指向cur,mostright.right=null,cur=cur.right.

cur来到空的时候停止.

特点:有左树的回来到两次,没有左树的只会来到一次.



Morris序改造先序:第一次来到一个节点就打印.

中序:第二次来到再打印.



### 3.Morris实现先序遍历.

在第一次来到这个节点的时候就进行打印.如果这个节点有左子树,在第一次来到的时候就打印,如果没有就直接打印.



### 4.Morris实现中序遍历.

在第二次来到这个节点的时候进行打印.也就是说,在节点向右跳转的时候就打印.



### 5.Morris实现后序遍历.

每次在来到右边界的时候,把这个右边界上的所有进行打印,最后再打印头结点边上的.使用链表的翻转,同时要注意还原.



### 6.Morris判断是不是搜索二叉树.

思路:实现中序遍历,记录前一个的值,如果发现前一个的值比当前的值要大或者相等的时候就说明不是.就是说在中序遍历进行打印的时候,就是来到这个位置的时候,在这个时候将当前值与之前的值进行一个比对,如果不符合条件就直接返回false.



### 7.求解二叉树的最小高度.叶节点才是产生高度的时候.

简单思路:如果有左树和右树,那么其高度就是左树和右树高度的最小值.如果没有左树或者右树,那么最小高度就是其中存在的一个加上1,因为没有叶子结点不能算高度.如果左树和右树都为空则返回1;空间复杂度O(h),h为树的高度.

复杂思路:使用morris遍历.

如果cur没有左树,那么将当前的level++,得到的就是下一层的高度.

如果cur有左树,那么可能两次来到自己.

level等级的更新:

首先记录当前的level为0

第二次到达的时候如果发现这个节点的左树也是空,说明这个节点就是叶子结点.



解题方法是左树右树分别要信息的时候,不能使用morris遍历,只能使用递归套路.



# 2.27

### 1.线段树.

需要实现的功能,

1.令指定范围上的每一个数增加一个值

2.令指定范围上的数都更改为某一个值

3.查询指定范围上数的和.

范围上更改,增加,求和的时间复杂度变为O(logN).

将原数组中的信息填到线段树数组中.

利用递归完成,要想得到当前值,要先得到左区间和右区间的.



范围上更新值:利用一个lazy数组,记录需要更新的位置.时间复杂度为O(logN).如果有多层任务,将任务下发一层,再接收任务.



整体思路:如果当前可以把任务拦住就直接拦,不用下发任务,这样来降低时间复杂度.每次下发任务之后要注意左边界和右边界的调整.



### 2.俄罗斯方块问题:

每次落下一个方块,求每一步方块的最高高度.

首先将每个位置离散化.也就是将所有的坐标从小到大排序之后,依次进行编号.例如一个点的坐标是100,200,离散化之后变为1,2

线段树,适合在L到R上统一进行一种操作.



### 3.涂色问题

用位运算表示颜色的种类.



### 4.最大线段重合问题.

首先将线段的左端点进行排序,依次将他们的右端点放进堆中.



### 5.区域内最多的矩形的个数

首先以底为判定条件,然后将矩形就抽象为了线段求和问题.



# 2.28

### 1.判断一颗二叉树是不是满二叉树

左树右树收集信息



### 2.判断是不是完全二叉树

执行宽度优先遍历,也就是层序遍历.

思路1:任何节点如果有右孩子没有左孩子则说明false.一旦遇到左右节点不双全则剩下的节点都必须为叶节点.

思路2:二叉树的几种情况.

1.满二叉树,无缺口,左满,右满,左右高度相等则为满二叉树

2.如果不满,那么只可能有如下几种情况\

​	左满右完全且高度相等

​	左完全右满且左比右高1.

​	左满右满高度相差1.



### 3.二叉树对数器的生成.

使用递归完成.用一个level控制当前生成的节点的等级.



### 4.给定一颗二叉树的头结点head,和另外两个节点a和b,返回a和b的最低公共祖先.

简单思路:首先根据二叉树生成一颗有父节点对应的哈希表.然后将题目给定的第一个节点的所有父节点放到一个集合中,再将第二个的父节点依次取出,第一个存在的父节点即为两者的最低公共祖先.

复杂思路:利用二叉树的递归套路.讨论在节点上有没有发现两个节点.

需要三个参数,最低相遇的节点,是否发现O1,是否发现O2.





# 3.1

### 1.在数组中找到累加和为固定值的最长子数组.都为正数

思路:使用一个窗口数组,如果窗口内的总和小于指定的sum,右边界右扩.如果大于指定sum,左边界右扩.如果恰好相等就更新.

套路:

1.看每个位置开头的答案是什么.

2.看每个位置结尾的答案是什么.



### 2.在数组中找到累加和为固定值的最长子数组,不止为正数.

思路:使用一个hashmap记录从开头到当前位置的累加和,走到数组中的一个位置,假设这个位置的累加和为sum,目标是k,那么相当于要从哈希表里面找到和为sum-k的最早的出现位置.



### 3.一个数组中可能存在正数负数0,求子数组中1和2的数量一样多的最长的数组.

思路:将数组中的数1不变,2变为-1,其他变为0,这样将问题就转化为累加和为0的最长子数组.



### 4.数组中可能出现任意数,求小于等于k的最长子数组.

思路:准备两个数组,其中一个记录数组中每个位置开始的最小值,另一个记录最小值位置处的索引.如果遇到0可以选择扩张或者不扩张.

然后开始从头遍历数组,来看从每一个位置开始的最小的累加和.如果这个位置的值都比要求的值大的话,则肯定不能以这个位置开头.如果开始的位置比要求的值小,则可以继续向后扩张.最终得到以第一个位置开头的最长的答案.然后从第二个位置开始看,并且右边界也开始右扩.因为在窗口内的答案肯定不能成立.
